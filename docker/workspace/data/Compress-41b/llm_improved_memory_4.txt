public ZipArchiveEntry getNextZipEntry() throws IOException {
    boolean firstEntry = true;
    if (closed || hitCentralDirectory) {
        return null;
    }
    if (current != null) {
        closeEntry();
        firstEntry = false;
    }

    try {
        if (firstEntry) {
            readFirstLocalFileHeader(LFH_BUF);
        } else {
            readFully(LFH_BUF);
        }
    } catch (EOFException e) {
        return null;
    }

    final ZipLong sig = new ZipLong(LFH_BUF);
    if (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) {
        hitCentralDirectory = true;
        skipRemainderOfArchive();
        return null;
    }
    if (!sig.equals(ZipLong.LFH_SIG)) {
        throw new ZipException(String.format("Unexpected record signature: 0X%X", sig.getValue()));
    }

    int off = WORD;
    current = new CurrentEntry();

    int versionMadeBy = ZipShort.getValue(LFH_BUF, off);
    off += SHORT;
    current.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT) & ZipFile.NIBLET_MASK);

    GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(LFH_BUF, off);
    boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();
    ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;
    current.hasDataDescriptor = gpFlag.usesDataDescriptor();
    current.entry.setGeneralPurposeBit(gpFlag);

    off += SHORT;

    current.entry.setMethod(ZipShort.getValue(LFH_BUF, off));
    off += SHORT;

    long time = ZipUtil.dosToJavaTime(ZipLong.getValue(LFH_BUF, off));
    current.entry.setTime(time);
    off += WORD;

    ZipLong size = null, cSize = null;
    if (!current.hasDataDescriptor) {
        current.entry.setCrc(ZipLong.getValue(LFH_BUF, off));
        off += WORD;

        cSize = new ZipLong(LFH_BUF, off);
        off += WORD;

        size = new ZipLong(LFH_BUF, off);
        off += WORD;
    } else {
        off += 3 * WORD;
    }

    int fileNameLen = ZipShort.getValue(LFH_BUF, off);

    off += SHORT;

    int extraLen = ZipShort.getValue(LFH_BUF, off);
    off += SHORT;

    byte[] fileName = new byte[fileNameLen];
    readFully(fileName);
    current.entry.setName(entryEncoding.decode(fileName), fileName);

    byte[] extraData = new byte[extraLen];
    readFully(extraData);
    current.entry.setExtra(extraData);

    if (!hasUTF8Flag && useUnicodeExtraFields) {
        ZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName, null);
    }

    processZip64Extra(size, cSize);

    if (current.entry.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN) {
        int method = current.entry.getMethod();
        if (method == ZipMethod.UNSHRINKING.getCode()) {
            current.in = new UnshrinkingInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));
        } else if (method == ZipMethod.IMPLODING.getCode()) {
            current.in = new ExplodingInputStream(gpFlag.getSlidingDictionarySize(),
                                                 gpFlag.getNumberOfShannonFanoTrees(),
                                                 new BoundedInputStream(in, current.entry.getCompressedSize()));
        } else if (method == ZipMethod.BZIP2.getCode()) {
            current.in = new BZip2CompressorInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));
        }
    }

    entriesRead++;
    return current.entry;
}