public TarArchiveEntry getNextTarEntry() throws IOException {
    if (hasHitEOF) {
        return null;
    }

    if (currEntry != null) {
        long numToSkip = entrySize - entryOffset;

        while (numToSkip > 0) {
            long skipped = skip(numToSkip);
            if (skipped <= 0) {
                throw new RuntimeException("failed to skip current tar entry");
            }
            numToSkip -= skipped;
        }

        readBuf = null;
    }

    byte[] headerBuf = getRecord();

    if (hasHitEOF) {
        currEntry = null;
        return null;
    }

    currEntry = createTarArchiveEntry(headerBuf);
    entryOffset = 0;
    entrySize = currEntry.getSize();

    if (currEntry.isGNULongNameEntry()) {
        handleGNULongName();
    }

    if (currEntry.isPaxHeader()) { // Process Pax headers
        paxHeaders();
    }

    if (currEntry.isGNUSparse()) { // Process sparse files
        readGNUSparse();
    }

    return currEntry;
}

private TarArchiveEntry createTarArchiveEntry(byte[] headerBuf) throws IOException {
    try {
        TarArchiveEntry entry = new TarArchiveEntry(headerBuf);
        return entry;
    } catch (IllegalArgumentException e) {
        throw new IOException("Error creating TarArchiveEntry", e);
    }
}

private void handleGNULongName() throws IOException {
    StringBuffer longName = new StringBuffer();
    byte[] buf = new byte[SMALL_BUFFER_SIZE];
    int length = 0;
    while ((length = read(buf)) >= 0) {
        longName.append(new String(buf, 0, length));
    }
    getNextEntry();
    if (currEntry == null) {
        // Bugzilla: 40334
        // Malformed tar file - long entry name not followed by entry
        return null;
    }
    // remove trailing null terminator
    if (longName.length() > 0 && longName.charAt(longName.length() - 1) == 0) {
        longName.deleteCharAt(longName.length() - 1);
    }
    currEntry.setName(longName.toString());
}