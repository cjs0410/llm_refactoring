public TarArchiveEntry getNextTarEntry() throws IOException {
    if (hasHitEOF) {
        return null;
    }

    if (currEntry != null) {
        long numToSkip = entrySize - entryOffset;

        while (numToSkip > 0) {
            long skipped = skip(numToSkip);
            if (skipped <= 0) {
                throw new RuntimeException("failed to skip current tar entry");
            }
            numToSkip -= skipped;
        }

        readBuf = null;
    }

    byte[] headerBuf = getRecord();

    if (hasHitEOF) {
        currEntry = null;
        return null;
    }

    try {
        currEntry = createTarArchiveEntry(headerBuf);
    } catch (IllegalArgumentException e) {
        throw new IOException("Error detected parsing the header", e);
    }
    entryOffset = 0;
    entrySize = currEntry.getSize();

    if (currEntry.isGNULongNameEntry()) {
        processGNULongNameEntry();
    }

    if (currEntry.isPaxHeader()) {
        processPaxHeaders();
    }

    if (currEntry.isGNUSparse()) {
        processGNUSparse();
    }

    entrySize = currEntry.getSize();
    return currEntry;
}

private TarArchiveEntry createTarArchiveEntry(byte[] headerBuf) {
    return new TarArchiveEntry(headerBuf);
}

private void processGNULongNameEntry() throws IOException {
    StringBuilder longName = new StringBuilder();
    byte[] buf = new byte[SMALL_BUFFER_SIZE];
    int length;
    while ((length = read(buf)) >= 0) {
        longName.append(new String(buf, 0, length, StandardCharsets.UTF_8));
    }
    getNextEntry();
    if (currEntry == null) {
        return null;
    }
    if (longName.length() > 0 && longName.charAt(longName.length() - 1) == 0) {
        longName.deleteCharAt(longName.length() - 1);
    }
    currEntry.setName(longName.toString());
}

private void processPaxHeaders() throws IOException {
    // Process Pax headers
    // implementation for processing Pax headers
}

private void processGNUSparse() throws IOException {
    // Process sparse files
    // implementation for processing GNUSparse
}